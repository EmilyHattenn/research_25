! This module solves the 1D Semiconductor Bloch equations
! in support of propagation simulations for a quantum wire.
module SBEs

    use types       ! Defines data types (double precision = (dp), etc.)
    use constants   ! Defines common math/physics constants (pi, e0, me0, hbar, etc.)
    use fftw        ! Contains functions for fast Fourier transform
    use helpers
    use spliner
    use usefulsubs
    use qwoptics
    use coulomb
    use phonons
    use emission
    use dcfield
    use dephasing
    use epsrtl
    use strings
    implicit none


    ! Initial QW Parameters
    real(dp),    private           :: L   = 100d-9        ! Length of quantum wire (m)
    real(dp),    private           :: Delta0 = 5d-9       ! z-thickness of quantum wire (m)
    real(dp),    private           :: gap = 1.5 * eV      ! Band gap (J, eV=1.6d-19 J)  1.53 eV
    real(dp),    private           :: me  = 0.07 * me0    ! Electron effective mass (kg, me0=9.11e-31 kg)
    real(dp),    private           :: mh  = 0.45 * me0    ! Electron effective mass (kg, me0=9.11e-31 kg)
    real(dp),    private           :: HO  = 100d-3 * eV   ! Energy level separation (J, default 100 meV)
    real(dp),    private           :: gam_e  = 1d0/1d-12  ! Electron lifetime frequency(Hz)
    real(dp),    private           :: gam_h  = 1d0/1d-12  ! Hole lifetime frequency (Hz)
    real(dp),    private           :: gam_eh = 1d0/1d-12  ! Energy level broading rate (Hz), gam_eh = (gam_e + gam_h)/2
    real(dp),    private           :: wL  = 0d0		      ! Laser frequency (rad/s), only for calculating chi1
    real(dp),    private           :: epsr = 9.1          ! Background dielectric constant
    real(dp),    private           :: Oph = 36d-3*eV/hbar ! Phonon frequency (Hz)
    real(dp),    private           :: Gph = 3d-3*eV/hbar  ! Inverse phonon lifetime (Hz)
    real(dp),    private           :: Edc = 0.0d6         ! Background DC field in +y-direction (V/m)


    ! Booleans SBE terms
    logical,  private              :: Optics     = .true.  ! Include basic optical coupling
    logical,  private              :: Excitons   = .true.  ! Include excitons & band gap renormalization (HTF-EH)
    logical,  private              :: EHs        = .true.  ! Include electron-hole (non-HTF) effects
    logical,  private              :: Screened   = .true.  ! Include carrier coulomb screening
    logical,  private              :: Phonon     = .true.  ! Include electron-phonon collisions
    logical,  private              :: DCTrans    = .false. ! Include transport from DC field
    logical,  private              :: LF         = .true.  ! Include influence of the longitudinal field
    logical,  private              :: FreePot    = .false. ! Include a free charge potential under dipol approximation
    logical,  private              :: DiagDph    = .true.  ! Include Diagonal Dephasing
    logical,  private              :: OffDiagDph = .true.  ! Include Off-Diagonal Dephasing
    logical,  private              :: OBE        = .false.  ! Ignore all Many-body effects and
                                                            ! just solve k-resolved OBEs

    logical,  private              :: Recomb     = .false.  ! Include electron-hole recombination (Default false)
    logical,  private              :: ReadDC     = .false.  ! Read in DC field value from file 
    logical,  private              :: PLSpec     = .false.   ! Record the Photoluminescence spectrum
    logical,  private              :: ignorewire = .false.
    logical,  private              :: debug1     = .false.
    logical,  private              :: Xqwparams  = .false.

    ! The Semiconductor Bloch Eq. arrays. There are three
    ! of each array. This is due to the time-evolution
    ! scheme, which requires a current and past
    ! value of a quantiy to compute its future value.        
    complex(dp), private, allocatable :: YY1(:,:,:)       ! EH Coherence for each wire at time t(n-1)
    complex(dp), private, allocatable :: YY2(:,:,:)       ! EH Coherence for each wire at time t(n  )
    complex(dp), private, allocatable :: YY3(:,:,:)       ! EH Coherence for each wire at time t(n+1)

    complex(dp), private, allocatable :: CC1(:,:,:)       ! EE Coherence for each wire at time t(n-1)
    complex(dp), private, allocatable :: CC2(:,:,:)       ! EE Coherence for each wire at time t(n  )
    complex(dp), private, allocatable :: CC3(:,:,:)       ! EE Coherence for each wire at time t(n+1)
    
    complex(dp), private, allocatable :: DD1(:,:,:)       ! HH Coherence for each wire at time t(n-1)
    complex(dp), private, allocatable :: DD2(:,:,:)       ! HH Coherence for each wire at time t(n  )
    complex(dp), private, allocatable :: DD3(:,:,:)       ! HH Coherence for each wire at time t(n+1)  
    
    complex(dp), private, allocatable :: qwPx(:,:)
    complex(dp), private, allocatable :: qwPy(:,:)
    complex(dp), private, allocatable :: qwPz(:,:)
      
    integer    , private, allocatable :: Id(:,:), Ia(:,:) ! Identity matrix and Anti-Identity matrix Ia = 1-Id

    ! QW arrays required for solving SBEs.
    real(dp), private, allocatable :: Ee(:)  , Eh(:)       ! Electron and hole energies (J)
    real(dp), private, allocatable :: r(:)   , Qr(:)       ! k_y arrays (1/m) for FFT
    real(dp), private, allocatable :: QE(:)  , kr(:)       ! k_y arrays (1/m) for practical use
    real(dp), private, allocatable :: Px0(:) , Px1(:)      ! Old polarizations to calc Jp = dP/dt
    real(dp), private, allocatable :: Px0W(:), Px1W(:)     ! Old polarizations to calc Jp = dP/dt
    real(dp), private, allocatable :: Py0(:) , Py1(:)      ! Old polarizations to calc Jp = dP/dt
    real(dp), private, allocatable :: Py0W(:), Py1W(:)     ! Old polarizations to calc Jp = dP/dt
    real(dp), private, allocatable :: Pz0(:) , Pz1(:)      ! Old polarizations to calc Jp = dP/dt
    real(dp), private, allocatable :: Pz0W(:), Pz1W(:)     ! Old polarizations to calc Jp = dP/dt
    real(dp), private              :: EPEnergy,EPEnergyW   ! Book keeping for total energy to wires
    real(dp), private, allocatable :: I0(:), ErI0(:)       ! Drift Current & E_Current in each wire
    real(dp), private              :: hw(500), PLS(500)    !
    real(dp), private              :: dkr, dr              ! dk (1/m), and dy (m)
    integer,  private              :: Nr1, Nr2		   ! Beginning & Ending yy-array points
    logical,  private              :: start=.false.        ! Has this module been initiated?


    ! TBD QW Parameters
    complex(dp), private           :: dcv                   ! Carrier dipole moment (C m)
    real(dp),    private           :: ehint = 1d0           ! Electron-Hole space integral, TBD, default is 1d0
    real(dp),    private           :: Emax0                 ! Initial Peak Field Value
    real(dp),    private           :: alphae, alphah, qc    ! Gaussian inverse radius of wire (1/m)
    real(dp),    private           :: area = 1d-16          ! Area of wire (m), 1d-16 is default, real value TBD
    real(dp),    private           :: t, wph                ! 
    complex(dp), private           :: chiw = 0d0
    real(dp),    private           :: vhh0 = 0d0
    real(dp),    private           :: ETHz = 0d0

    ! Initial Numerical parameters
    integer,  private		       :: Nr		        ! # of points in quantum wire y-space
    integer,  private              :: Nk                ! # of points in reduced quantum wire k-space (Nr/2-1)
    real(dp), private              :: small = 1d-200    ! Smallest # worthy of consideration

    ! TBD Numerical Parameters
    integer,  private	           :: NK0, NQ0           ! Frequency equal zero index
    integer,  private              :: nqq, nqq10
    integer,  private, allocatable :: kkp(:,:)	   	     ! kr - krp index matrix

    ! SBE Booleans
    logical,  private              :: wireoff = .true.    ! Wait to turn QW on when field is strong
    
    
    ! Book keeping variables for printing of data
    integer, private               :: xxx  = 1
    integer, private               :: jjj  = 1
    integer, private               :: jmax = 1000
    integer, private              :: ntmax = 100000
    integer, private               :: uw   = 820
    
    
    
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
contains
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



    ! Time-evolves the source terms of the quantum wire
    ! for Maxwell's equations. Solves the 1D semiconductor 
    ! Bloch equations.
    subroutine QWCalculator(Exx, Eyy, Ezz, Vrr, rr, q, dt, w, Pxx, Pyy, Pzz, Rho, DoQWP, DoQWDl)
        ! Input required for calculation
        complex*16, intent(in   ) :: Exx(:), Eyy(:)     ! X & Y Total Electric fields
        complex*16, intent(in   ) :: Ezz(:), Vrr(:)     ! Z & potential Electric fields
        real(dp),   intent(in   ) :: rr(:) , q(:)       ! QW spatial & momentum arrays
        real(dp),   intent(in   ) :: dt                 ! Time step
        integer                   :: w                  ! Which wire am I calculating for (does nothing yet)

        ! Output From SBEs to Maxwell Propagator
        complex*16, intent(inout) :: Pxx(:) , Pyy(:), Pzz(:) ! X, Y, Z  polarizations
        complex*16, intent(inout) :: Rho(:)             ! Free  Charge density
        logical,    intent(inout) :: DoQWP  , DoQWDl    ! Should the propagator bother with the above quantities

        ! Fields & sources in the wire
        complex*16  :: Ex(Nr), Ey(Nr), Ez(Nr), Vr(Nr) ! X & Y Electric fields and potential in QW (2*Nr # of points)
        complex*16  :: Px(Nr), Py(Nr), Pz(Nr)           ! X & Y Polarizations in QW
        complex*16  :: re(Nr), rh(Nr)                   ! E&H charge densities in QW
        logical     :: WriteFields = .false.            ! Record results on this time step or no?
        complex*16  :: RhoE(size(rr)), RhoH(size(rr))   ! Free  Charge density
        real(dp)    :: Edc0, tau
        real(dp)    :: ps=1d-12

        WriteFields = .false.
        
        ! Initialize source terms for propagator
        Pxx  = 0d0
        Pyy  = 0d0
        Pzz  = 0d0
        Rho  = 0d0

        
        ! Book keeping. Do this only once per time step.
        ! So only when calculating for the first wire.
        if(w==1) then
            if(jjj==jmax) jjj=0

            xxx = xxx+1
            jjj = jjj+1
            t   = t + dt

            if(jjj==jmax) PLS = 0d0
        end if        

        ! Record results only 1 out of every jmax times
        if(jjj==jmax) WriteFields = .true.

        
        ! Only do the QW calculation on if the field was once large compared
        ! to its initial maximum value.  Otherwise just do book keeping.
        if(wireoff .and. maxval(sqrt((magsq(Exx)+magsq(Eyy)+magsq(Ezz)))) < 1d-3 * Emax0) then
            ! E isn't big enough yet.  Do nothing.
            return    
        else
            ! E is (or was) big enough.  Commence Calculations!
            wireoff = .false.
            DoQWP   = Optics
            DoQWDl  = LF
        endif

tau  = t - 4*ps
ETHz = Edc * exp(- tau**2 / ps**2) * sin(twopi*tau/ps) * exp(- tau**12 / (2*ps)**12)
write(923,*) t, ETHz

	if(.not.allocated(qwPx)) then
            allocate(qwPx(size(rr), size(CC1,3)))
            allocate(qwPy(size(rr), size(CC1,3)))
            allocate(qwPz(size(rr), size(CC1,3)))
            qwPx = 0d0
            qwPy = 0d0
            qwPz = 0d0
        endif


     
        ! Create QW fields (y-space and Qr-space) from Propagation fields (yy-space)
        call Prop2QW(rr, Exx, Eyy, Ezz, Vrr, Edc0, r, Ex, Ey, Ez, Vr, t, xxx)       


	if(debug1) then
            Px = eps0 * 1d0 * Ex
            Py = eps0 * 1d0 * Ey
            Pz = eps0 * 1d0 * Ez
            re = 0d0
            rh = 0d0
	else
            ! Solve SBEs for the w'th quantum wire and return
            ! the values for the QW sources Px, Py, Re, Rh
            call SBECalculator(Ex, Ey, Ez, Vr, dt, Px, Py, Pz, Re, Rh, WriteFields, w)
        endif        

        ! FFT QW Qr-fields and interpolate them to the Propagation YY-space.
        ! Also record all field values for time index xxx if WriteFields boolean is true.
        call QW2Prop(r, Qr, Ex, Ey, Ez, Vr, Px, Py, Pz, re, rh, rr, Pxx, Pyy, Pzz, RhoE, RhoH, w, xxx, WriteFields, LF)

        Rho = RhoH - RhoE

        if(WriteFields) call WritePropFields(rr, Exx, Eyy, Ezz, Vrr, Pxx, Pyy, Pzz, Rhoe, RhoH, 'r', w, xxx)

	if(.not.allocated(Px0)) then
	
            allocate(Px0(size(Pxx)))
            allocate(Px1(size(Pxx)))
            allocate(Px0W(size(Px )))
            allocate(Px1W(size(Px )))
            Px0  = 0d0
            Px1  = 0d0
            Px0W = 0d0
            Px1W = 0d0
            allocate(Py0(size(Pyy)))
            allocate(Py1(size(Pyy)))
            allocate(Py0W(size(Py )))
            allocate(Py1W(size(Py )))
            Py0  = 0d0
            Py1  = 0d0
            Py0W = 0d0
            Py1W = 0d0
            allocate(Pz0(size(Pzz)))
            allocate(Pz1(size(Pzz)))
            allocate(Pz0W(size(Pz )))
            allocate(Pz1W(size(Pz )))
            Pz0  = 0d0
            Pz1  = 0d0
            Pz0W = 0d0
            Pz1W = 0d0
            EPEnergy  = 0d0
            EPEnergyW = 0d0
            open(file="PdotE.p.dat",unit=972)
            open(file="PdotE.w.dat",unit=973)
        end if

        EPEnergy = EPEnergy   + sum( (real(Pxx)-Px0 )*real(Exx)*0.5d0 ) * (rr(2)-rr(1)) * area &
                              + sum( (real(Pyy)-Py0 )*real(Eyy)*0.5d0 ) * (rr(2)-rr(1)) * area &
                              + sum( (real(Pzz)-Pz0 )*real(Ezz)*0.5d0 ) * (rr(2)-rr(1)) * area
        EPEnergyW = EPEnergyW + sum( (real(Px )-Px0W)*real(Ex )*0.5d0 ) *      dr       * area &
                              + sum( (real(Py )-Py0W)*real(Ey )*0.5d0 ) *      dr       * area &
                              + sum( (real(Pz )-Pz0W)*real(Ez )*0.5d0 ) *      dr       * area
        Px0  = Px1
        Px1  = real(Pxx)
        Px0W = Px1W
        Px1W = real(Px)
        Py0  = Py1
        Py1  = real(Pyy)
        Py0W = Py1W
        Py1W = real(Py)
        Pz0  = Pz1
        Pz1  = real(Pzz)
        Pz0W = Pz1W
        Pz1W = real(Pz)
        write(972,*) t, EPEnergy  / e0
        write(973,*) t, EPEnergyW / e0


        if(ignorewire) then
            Pxx  = 0d0
            Pyy  = 0d0
            Pzz  = 0d0
            Rho  = 0d0
        endif

    end subroutine QWCalculator





    
    ! Solves the 1D semiconductor Bloch equations
    ! and calculates the source terms Px, Py, Re, 
    ! and Rh for the w'th quantum wire.
    subroutine SBECalculator(Ex, Ey, Ez, Vr, dt, Px, Py, Pz, Re, Rh, WriteFields, w)
        ! Input required for calculation
        complex*16, intent(inout) :: Ex(:), Ey(:)       ! The X & Y electric fields in QW
        complex*16, intent(inout) :: Ez(:), Vr(:)       ! Z electric field and free charge potential (voltage)
        real(dp),   intent(in   ) :: dt                 ! Time step
        ! Fields & sources in the wire
        complex*16, intent(inout) :: Px(:), Py(:), Pz(:)! X & Y & Z QW Polarization fields
        complex*16, intent(inout) :: Re(:), Rh(:)       ! QW Electron and Hole charge densities
        logical   , intent(in   ) :: WriteFields        ! Do we record the SBE solutions this time
        ! Which wire are we calulating for
        integer,    intent(in   ) :: w                  ! QW index


        ! Arrays for the reduced SBE k-space
        complex*16  :: ne1(Nk), nh1(Nk)   ! Electron/hole occupation numbers at time t(n-1)
        complex*16  :: ne2(Nk), nh2(Nk)   ! Electron/hole occupation numbers at time t(n  )
        complex*16  :: ne3(Nk), nh3(Nk)   ! Electron/hole occupation numbers at time t(n+1)
        
        complex*16  :: p1(Nk,Nk)          ! Electron/hole coherence at time t(n-1)
        complex*16  :: p2(Nk,Nk)          ! Electron/hole coherence at time t(n  )
        complex*16  :: p3(Nk,Nk)          ! Electron/hole coherence at time t(n+1)
        
        complex*16  :: C1(Nk,Nk)          ! Electron/electron coherence at time t(n-1)
        complex*16  :: C2(Nk,Nk)          ! Electron/electron coherence at time t(n  )
        complex*16  :: C3(Nk,Nk)          ! Electron/electron coherence at time t(n+1)
        
        complex*16  :: D1(Nk,Nk)          ! Hole/hole coherence at time t(n-1)
        complex*16  :: D2(Nk,Nk)          ! Hole/hole coherence at time t(n  )
        complex*16  :: D3(Nk,Nk)          ! Hole/hole coherence at time t(n+1)
        
        complex*16  :: dpdt2(Nk,Nk)       ! SBE dp/dt  at time t(n)
        complex*16  :: dCdt2(Nk,Nk)       ! SBE dEE/dt at time t(n)
        complex*16  :: dDdt2(Nk,Nk)       ! SBE dHH/dt at time t(n)
        
        complex*16  :: Hee(Nk,Nk)         ! Hamiltonian e-e matrix elements
        complex*16  :: Hhh(Nk,Nk)         ! Hamiltonian h-h matrix elements
        complex*16  :: Heh(Nk,Nk)         ! Hamiltonian e-h matrix elements        
        
        complex(dp) :: OffG(Nk,Nk,3)      ! Off-Diagonal Dephasing term
        real(dp)    :: VC(Nk,Nk,3)        ! Real-time screened Coulomb arrays
        real(dp)    :: E1D(Nk,Nk)         ! Real-time screening array (for carrier-photon calc)
        real(dp)    :: GamE(Nk), GamH(Nk) ! Diagonal elec/hole dephasing rates
        real(dp)    :: Rsp(Nk)            ! Spontaneous Emission Rate
        real(dp)    :: total, total1
        complex*16  :: Ene(Nk), Enh(Nk)   ! Electron/Hole corrected energies

        ! Integers needed for loops and testing
        integer     :: k, kk, kp, i, k1, k2


        ! Initialize source terms
        Px = 0d0
        Py = 0d0
        Pz = 0d0
        Re = 0d0
        Rh = 0d0

      Ia = 1
      Id = 0
      do k=1, Nk
          Ia(k,k) = 0
          Id(k,k) = 1
      end do
      
        call Checkout(P1, P2, C1, C2, D1, D2, w)

        ! Prepare the needed arrays for the SBEs
        call Preparation(P2, C2, D2, Ex, Ey, Ez, Vr, Heh, Hee, Hhh, VC, E1D, GamE, GamH, OffG, Rsp)

        forall(k=1:Nk) Ene(k) = Hee(k,k) / eV
        forall(k=1:Nk) Enh(k) =	Hhh(k,k) / eV

        

          
        ! Do the real work here by calculating the SBEs
        dpdt2  = dpdt( C2, D2, p2, Heh, Hee, Hhh, GamE, GamH, OffG(:,:,1))
        dCdt2  = dCdt( C2, D2, p2, Heh, Hee, Hhh, GamE, GamH, OffG(:,:,2))
        dDdt2  = dDdt( C2, D2, p2, Heh, Hee, Hhh, GamE, GamH, OffG(:,:,3))


        ! Time evolve by leapfrog
        C3  = C1 + dCdt2 * dt * 2d0
        D3  = D1 + dDdt2 * dt * 2d0
        p3  = p1 + dpdt2 * dt * 2d0


        if(EHs .or. phonon) then
            forall(k=1:Nk) ne3(k) = C3(k,k) 
            forall(k=1:Nk) nh3(k) = D3(k,k) 
                call Relaxation(ne3, nh3, VC, E1D, Rsp, dt, w, writefields)
            forall(k=1:Nk) C3(k,k) = ne3(k) 
            forall(k=1:Nk) D3(k,k) = nh3(k) 
        end if


        if(DCTrans) then
            call Transport(C3, ETHz, 0d0*real(Ey(NQ0)), dt, DCTrans, LF)
            call Transport(D3, ETHz, 0d0*real(Ey(NQ0)), dt, DCTrans, LF)
            call Transport(p3, ETHz, 0d0*real(Ey(NQ0)), dt, DCTrans, LF)
        end if


        forall(k=1:Nk) ne3(k) = abs(C3(k,k))
        forall(k=1:Nk) nh3(k) = abs(D3(k,k)) 
        !Make sure total electrons equals total holes)
        total = (sum(abs(ne3)) + sum(abs(nh3))) / 2d0
        ne3   = ne3 * total / (sum(abs(ne3)) + small) 
        nh3   = nh3 * total / (sum(abs(nh3)) + small)
        forall(k=1:Nk) C3(k,k) = ne3(k) 
        forall(k=1:Nk) D3(k,k) = nh3(k) 


        ! Must reshuffle for integration scheme to be stable!!!
        ! This turns the 2nd order acurate (but unstable) leapfrog scheme
        ! into a 1st order accurate (but stable) implicit Euler scheme.
        p2 = (p1+p3) / 2d0
        C2 = (C1+C3) / 2d0        
        D2 = (D1+D3) / 2d0

        forall(k=1:Nk) ne2(k) = abs(C2(k,k))
        forall(k=1:Nk) nh2(k) = abs(D2(k,k)) 
        
        if (WriteFields) call WriteSBESolns(kr, ne3, nh3, C3, D3, P3, Ene, Enh, w, xxx)

        !if (WriteFields) call RecordXqw(kr, real(ne3), real(nh3), Ee, Eh, gap, area, gam_eh, dcv, xxx)

        if (WriteFields .and. DiagDph) call WriteDephasing(kr, gamE, gamH, w, xxx)

        !if (WriteFields) then
        !    call PLSpectrum(ne3, nh3, Ee, Eh, gap, gam_eh, VC, hw, xxx*dt-100d-15, PLS)
        !    
        !    if (w==size(fe3,2)) call WritePLSpectrum(hw, PLS, w, xxx)
        !end if
            
        ! Calculate the X & Y components of the QW Polarization
        if(optics) call QWPolarization3(r, kr, p3, ehint, area, L, Px, Py, Pz, xxx)
        
        !if(optics) then        
        !    call QWPolarization4(r, kr, ehint, area, L, dt, D3, D3, P3, Hee, Hhh, Heh, qwPx(:,w), qwPy(:,w), qwPz(:,w), xxx)
        !    Px = qwPx(:,w)
        !    Py = qwPy(:,w)
        !    Pz = qwPz(:,w)
        !end if
        
        
        
        ! Calculate new electron and hole charge densities
        if(LF) then
            call QWRho5(Qr, kr, r, L, kkp, p3, C3, D3, ne3, nh3, re, rh, xxx, jjj)
            re = 2 * e0 * re  / area * ehint
            rh = 2 * e0 * rh  / area * ehint            
        else
            re = 0d0
            rh = 0d0
        endif
      
        
        if(w==ceiling(size(I0)/2d0) .and. WriteFields) then
            write(6,"(I8,A,5ES18.6E3)") xxx, "Elec", sum(real(ne3)) , maxval(real(ne3))  , minval(real(ne3))         &
                                                   , CalcVD(kr, me, ne3), real(CalcPD(kr, me, ne3))
            write(6,"(I8,A,5ES18.6E3)") xxx, "Hole", sum(real(nh3)) , maxval(real(nh3))  , minval(real(nh3))         &
                                                   , CalcVD(kr, mh, nh3), real(CalcPD(kr, mh, nh3))    
        end if

        call CalcI0(ne2, nh2, Ee, Eh, VC, dkr, kr, I0(w))
        !call CalcI0(ne2, nh2, hbar**2*kr**2/(2d0*me), hbar**2*kr**2/(2d0*mh), VC, dkr, kr, I0(w))

        
        write(uw+w,"(18ES18.6E3)") xxx*dt, CalcVD(kr, me, ne2)         , CalcVD(kr, mh, nh2),    & 
                                           real(2*sum(ne2)/L)          , real(2*sum(nh2)/L) ,    & 
                                           TotalEnergy(ne2,Ee+gap)/e0  , TotalEnergy(nh2,Eh)/e0, &
                                           Temperature(ne2,Ee)         , Temperature(nh2,Eh),    &
                                           maxval(abs(re))             , maxval(abs(rh))    ,    &
                                           GetEDrift()                 , real(hbar*sum((ne2-nh2)*kr)) * 2d0, &
                                           real(hbar*sum(ne2*kr))      , real(-hbar*sum(nh2*kr)),&
                                           I0(w)                       , calcI0n(ne2,me,kr) ,    &
                                           calcI0n(1-nh2,-mh,kr)

        call iFFTG(Ex(:))
        call iFFTG(Ey(:))
        call iFFTG(Ez(:))
        call iFFTG(Px(:))
        call iFFTG(Py(:))
        call iFFTG(Pz(:))
        
        write(2*uw+w,"(7ES18.6E3)") xxx*dt, real(Ex(Nr/2))    , real(Ey(Nr/2))     , real(Ez(Nr/2)) &
                                          , real(Px(Nr/2))    , real(Py(Nr/2))     , real(Pz(Nr/2))

        call FFTG(Ex(:))
        call FFTG(Ey(:))
        call FFTG(Ez(:))
        call FFTG(Px(:))
        call FFTG(Py(:))
        call FFTG(Ez(:))
        
        !call Checkin(ne1, ne2, ne3, nh1, nh2, nh3, p1, p2, p3, w)
        call Checkin(P1, P2, P3, C1, C2, C3, D1, D2, D3, w)
    end subroutine SBECalculator



    ! Calculates the SBE for electrons
    subroutine Relaxation(ne, nh, VC, E1D, Rsp, dt, w, writefields)
        complex(dp), intent(inout) :: ne(:), nh(:)                  ! Carrier populations
        real(dp),    intent(in)    :: VC(:,:,:), E1D(:,:)           ! Screened Coulomb Arrays, and screening array
        real(dp),    intent(in)    :: Rsp(:)                        ! Spontaneous Emission Rate
        real(dp),    intent(in)    :: dt
        integer,     intent(in)    :: w
        logical,     intent(in)    :: writefields
        complex(dp)                :: dnedt(size(ne))               ! Time derivative of n_e
        real(dp)                   :: WinE(size(ne)), WoutE(size(ne)) ! Many-body In/Out rates
        real(dp)                   :: WinH(size(ne)), WoutH(size(ne)) ! Many-body In/Out rates
        character(len=50)          :: fmt, wire        


        fmt = '(I2.2)'
        write(wire,fmt) w


        if(EHs .or. phonon) then
            call RelaxationE(ne, nh, VC, E1D, WinE, WoutE)
            call RelaxationH(ne, nh, VC, E1D, WinH, WoutH)

            if(WriteFields) then
            call printITR(WinE*(1-real(ne)) ,  kr, xxx, 'Wire/Win/Win.e.'//trim(wire)//'.k.')
            call printITR(WinH*(1-real(nh)) ,  kr, xxx, 'Wire/Win/Win.h.'//trim(wire)//'.k.')
            call printITR(WoutE * real(ne)  ,  kr, xxx, 'Wire/Wout/Wout.e.'//trim(wire)//'.k.')
            call printITR(WoutH * real(nh)  ,  kr, xxx, 'Wire/Wout/Wout.h.'//trim(wire)//'.k.')
            endif

            ne = exp(-(WinE+WoutE)*dt) * ( (-1 + exp(+(WinE+WoutE)*dt) + ne)*WinE + ne*WoutE)/(WinE+WoutE+small)
            nh = exp(-(WinH+WoutH)*dt) * ( (-1 + exp(+(WinH+WoutH)*dt) + nh)*WinH + nh*WoutH)/(WinH+WoutH+small)

            !ne = ne + WinE*(1d0 - ne)*dt - WoutE*ne*dt
            !nh = nh + WinH*(1d0 - nh)*dt - WoutH*nh*dt
        end if 

        if(recomb) then
            ne(:) = ne(:) * exp(- Rsp(:) * nh(:) * dt)
            nh(:) = nh(:) * exp(- Rsp(:) * ne(:) * dt)
        end if
    end subroutine





    ! Calculates the SBE for coherence between electrons & holes
    ! See Eqs. 2.15-2.19 in:
    ! V M Axt and T Kuhn, Rep. Prog. Phys, 67, 433 (2004)
    function dpdt(C, D, p, Heh, Hee, Hhh, GamE, GamH, OffP)
        complex(dp), intent(in) :: C(:,:)                       ! Electron-hole coherence
        complex(dp), intent(in) :: D(:,:)                       ! Electron-electron coherence
        complex(dp), intent(in) :: P(:,:)                       ! Hole-hole coherence
        complex(dp), intent(in) :: Heh(:,:), Hee(:,:), Hhh(:,:) ! Hamiltonian matrix elements
        real(dp),    intent(in) :: GamE(:), GamH(:)             ! Diagonal elec/hole dephasing rates
        complex(dp), intent(in) :: OffP(:,:)                    ! Off-Diagonal Dephasing term
        complex(dp)             :: dpdt(Nk,Nk)                  ! Time derivative of e-h coherence
        integer                 :: ke, kh, f                    ! Electron/hole momentum index
        Complex(dp)             :: Heht(Nk,NK),Hhht(Nk,Nk)
        Complex(dp)             :: Pt(Nk,NK)
        complex(dp)             :: Ene(Nk)
        complex(dp)             :: Enh(Nk)

        dpdt = 0d0

          Pt = transpose(P)
        Heht = transpose(Heh)
        Hhht = transpose(Hhh)

        !$omp parallel do private(ke, kh)
        do ke=1, Nk
            do kh=1, Nk
 
                dpdt(kh,ke) = + sum(Hhh(kh,:) * P(:,ke) + Hee(ke,:) * P(kh,:) )              &
                              - sum(Heh(:,kh) * C(:,ke) + Heh(ke,:) * D(:,kh) ) + Heh(ke,kh) &
                              - ii*hbar*(GamE(ke)+GamH(kh)) * P(kh,ke) + OffP(kh,ke)
            end do
        end do
        !$omp end parallel do
        dpdt = dpdt / (ii*hbar)
    end function



    ! Calculates the SBE for coherence between electrons
    ! See Eqs. 2.15-2.19 in:
    ! V M Axt and T Kuhn, Rep. Prog. Phys, 67, 433 (2004)
    function dCdt(Cee, Dhh, Phe, Heh, Hee, Hhh, GamE, GamH, OffE)
        complex(dp), intent(in) :: Cee(:,:), Dhh(:,:), Phe(:,:) ! Electron-Electron coherence arrays
        complex(dp), intent(in) :: Heh(:,:), Hee(:,:), Hhh(:,:) ! Hamiltonian Matrix elements
        real(dp),    intent(in) :: GamE(:), GamH(:)             ! Diagonal elec/hole dephasing rates
        complex(dp), intent(in) :: OffE(:,:)                    ! Off-Diagonal Dephasing term
        complex(dp)             :: dCdt(Nk,Nk)                  ! Time derivative of e-e coherence
        integer                 :: k1, k2                       ! Electron/hole momentum index
        complex(dp)             :: Hhe(Nk,Nk)
        complex(dp)             :: Peh(Nk,Nk)

        dCdt = 0d0
         Hhe = transpose(conjg(Heh))
         Peh = transpose(conjg(Phe))
         
                 
        !$omp parallel do private(k1, k2)
        do k2=1, Nk
            do k1=1, Nk
 
                dCdt(k1,k2) = + sum(Hee(k2,:) * Cee(k1,:) - Hee(:,k1) * Cee(:,k2) ) & 
                              + sum(Heh(k2,:) * Peh(k1,:) - Hhe(:,k1) * Phe(:,k2) ) &
                              - ii*hbar*Ia(k1,k2)*(GamE(k1)+GamE(k2)) * Cee(k1,k2)  &
                              + OffE(k1,k2)
            end do
        end do
        !$omp end parallel do
        dCdt = dCdt / (ii*hbar)       
    end function


    ! Calculates the SBE for coherence between electrons
    ! See Eqs. 2.15-2.19 in:
    ! V M Axt and T Kuhn, Rep. Prog. Phys, 67, 433 (2004)
    function dDdt(Cee, Dhh, Phe, Heh, Hee, Hhh, GamE, GamH, OffH)
        complex(dp), intent(in) :: Cee(:,:), Dhh(:,:), Phe(:,:) ! Electron-Electron coherence arrays
        complex(dp), intent(in) :: Heh(:,:), Hee(:,:), Hhh(:,:) ! Hamiltonian matrix elements
        real(dp),    intent(in) :: GamE(:), GamH(:)             ! Diagonal elec/hole dephasing rates
        complex(dp), intent(in) :: OffH(:,:)                    ! Off-Diagonal Dephasing term
        complex(dp)             :: dDdt(Nk,Nk)                  ! Time derivative of h-h coherence
        integer                 :: k1, k2                       ! Electron/hole momentum index
        complex(dp)             :: Hhe(Nk,Nk)
        complex(dp)             :: Peh(Nk,Nk)
        complex(dp)             :: Dt(Nk,Nk)


        dDdt = 0d0
        Peh  = transpose(conjg(Phe))
        Hhe  = transpose(conjg(Heh))        
        
        !$omp parallel do private(k1, k2)
        do k2=1, Nk
            do k1=1, Nk
                dDdt(k1,k2) = + sum(Hhh(k2,:) * Dhh(k1,:) - Hhh(:,k1) * Dhh(:,k2) ) & 
                              + sum(Heh(:,k2) * Peh(:,k1) - Hhe(k1,:) * Phe(k2,:) ) &
                              - ii*hbar*Ia(k1,k2)*(GamH(k1)+GamH(k2)) * Dhh(k1,k2) &
                              + OffH(k1,k2)
            end do
        end do
        !$omp end parallel do
        dDdt = dDdt / (ii*hbar)          
    end function



    subroutine CalcMeh(Ex, Ey, Ez, Meh)
        complex(dp), intent(in   ) :: Ex(:), Ey(:), Ez(:)  ! Electric field in x & y directions
        complex(dp), intent(inout) :: Meh(Nk,Nk)
        integer                    :: ke, kh, q

        Meh = 0d0

        do kh=1, Nk
            do ke=1, Nk
                ! I know this q SHOULD be q = ke-kh in the formalism.
                ! But we use IFFT instead of FFT for {Ex,Ey,Ez,Vr},
                ! so THIS q = kh - ke
                ! EXCEPT, now I corrected it!  We don't use ifft anymore!
                q = kkp(ke, kh)
                Meh(ke,kh) =  - ehint * Xcv(ke,kh) * Ex(q)  - ehint * Ycv(ke,kh) * Ey(q) - ehint * Zcv(ke,kh) * Ez(q)
            end do
        end do       
    end subroutine



    subroutine CalcWnn(q0, Vr, Wnn)
        real(dp)   , intent(in   ) :: q0         ! Free charge of electron or holes (+e0 or -e0)
        complex(dp), intent(in   ) :: Vr(:)      ! Electric potential from free charge
        complex(dp), intent(inout) :: Wnn(Nk,Nk) ! Free charge potential matrix element
        integer                    :: k1, k2, q

        Wnn = 0d0

        do k2=1, Nk
            do k1=1, Nk
                ! I know this q SHOULD be q = k1-k2 in the formalism.
                ! But we use IFFT instead of FFT for {Ex,Ey,Ez,Vr},
                ! so THIS q = k2 - k1
                ! EXCEPT, now I corrected it!  We don't use ifft anymore!
                q = kkp(k1, k2)
                Wnn(k1,k2) =  q0 * Vr(q)
            end do
        end do
    end subroutine



    ! This subroutine initializes this module for calculations.
    ! It allocates all the private modular arrays, initializes
    ! them to zero, as well as calculates material constants.
    subroutine InitializeSBE(q, rr, r0, Emaxxx, lam, Nw, QW)

        double precision, intent(in)    :: q(:), rr(:)      ! Momentum & spatial arrays
        double precision, intent(in)    :: r0, Emaxxx, lam
        integer,          intent(in)    :: Nw               ! number of quantum wires
        logical,          intent(in)    :: QW
        double precision                :: kmax
        integer                         :: i, k, kp, w
        character(len=8)                :: wire
        real(dp), allocatable           :: game(:), gamh(:)
        real(dp)                        :: a = 5.6d-10


    if(QW) then

        call ReadQWParams()
        call ReadMBParams()

        Emax0 = Emaxxx
        t     = 0d0

       !kmax  = sqrt((0.8*Gap) * 2d0 * me / hbar**2)
        kmax  = sqrt((1.2*Gap) * 2d0 * me / hbar**2) !* 2
        dkr   = twopi / (2*L) 
        Nk    = floor(kmax / dkr) * 2 + 1
        Nr    = Nk * 2

	!if(Nf==1) then
        Nk=Nk-1
       
        ! Allocate field y-space and q-space (FFT transformed space) arrays
        allocate( r(Nr))
        allocate(Qr(Nr))

        ! Allocate the practical field Q-space array (without extra FFT point)
        allocate(QE(Nr-1))

        ! Momentum space arrays for the SBEs
        allocate(kr(Nk))
        allocate(Ee(Nk)    , Eh(Nk))

        allocate(I0(Nw), ErI0(Nw))
        
        allocate( YY1(Nk,Nk,Nw), YY2(Nk,Nk, Nw), YY3(Nk,Nk,Nw))
        allocate( CC1(Nk,Nk,Nw), CC2(Nk,Nk, Nw), CC3(Nk,Nk,Nw))
        allocate( DD1(Nk,Nk,Nw), DD2(Nk,Nk, Nw), DD3(Nk,Nk,Nw))       
        allocate( Id(Nk,Nk)    , Ia(Nk,Nk))

        ErI0 = 0d0
        I0   = 0d0

        Id = 0
        forall(k=1:Nk) Id(k,k) = 1
        Ia = 1-Id


        ! Calculate needed spatial & momentum arrays for SBE calculations
        call GetArrays(r, Qr, kr)
        dr   = (r(3) - r(2)) * (Nr-1) / (Nr*1d0)


        ! Calculate Material constants
        dcv    = sqrt((e0*hbar)**2 / (6*me0*gap) * (me0/me - 1d0))
        alphae = sqrt(me * HO) / hbar
        alphah = sqrt(mh * HO) / hbar       
        ehint  = sqrt(2 * alphae * alphah / (alphae**2 + alphah**2))
        gam_eh = (gam_e + gam_h ) / 2d0
        qc     = 2 * alphae * alphah / (alphae + alphah)!(alphae + alphah) / 2d0

        area   = sqrt(pi) / qc  * Delta0

        print*, dcv / e0
        print*, alphae, alphah
        print*, 1/qc, sqrt(2.0) / sqrt(alphae**2 + alphah**2)

        area = sqrt(2*pi) / sqrt(alphae**2 + alphah**2)  * Delta0

        print*, "ehint = ", ehint
        print*, "Wire Radius =",     1 / qc!, sqrt(area/pi)
        print*, "Wire sqrt(area) =", sqrt(area)
        print*, "Wire Thickness =", Delta0
    
        ! Calculate band structure
        Ee = hbar**2 * kr**2 / 2d0 / me
        Eh = hbar**2 * kr**2 / 2d0 / mh
        
        !Ee = hbar**2 / a**2 / me * (1 - cos(kr*a))
        !Eh = hbar**2 / a**2 / mh * (1 - cos(kr*a))        

        ! Initialize the arrays
        CC1 = 0d0
        DD1 = 0d0
        YY1 = 0d0
        forall(k=1:Nk) CC1(k,k,:)  = FermiDistr(Ee+gap/2d0)
        forall(k=1:Nk) DD1(k,k,:)  = FermiDistr(Ee+gap/2d0)
        CC2 = CC1
        CC3 = CC1
        DD2 = DD1
        DD3 = DD1
        YY2 = 0d0
        YY3 = 0d0



        ! Calculate QW window within Y-array
        Call InitializeQWOptics(r,L,dcv,kr,Qr,Ee,Eh,ehint, area, gap)


        call WriteIt(kr   , "kr")
        call WriteIt(Qr   , "Qr")
        call WriteIt(r    , "R")
        call WriteIt(Ee/eV, "Ee.k")
        call WriteIt(Eh/eV, "Eh.k")
        call WriteIt((Ee+Eh+Gap-hbar*c0*twopi/lam)/eV, "Echw.k")
        call WriteIt((Ee+Eh+Gap)/eV, "Etrn.k")

        open(unit=666,file="dataQW/Etr.dat")
        do i=1, size(kr)
            write(666,*) kr(i), (Ee(i)+Eh(i)+Gap)/eV!*4e-3
        end do
        close(666)

      
        if(OBE) then
            Optics   = .true.
            Excitons = .false.
            EHs      = .false.
            Phonon   = .false.
            recomb   = .false.
            LF       = .false.
            DCTrans  = .false.
        endif


        call MakeKKP()        
    

        ! Calculate constant material arrays
        call InitializeCoulomb(r, kr, L, Delta0, me, mh, Ee, Eh, gam_e, gam_h, alphae, alphah, epsr, Qr, kkp, screened)

        call InitializePhonons(kr, Ee, Eh, L, epsr, Gph, Oph)
        
        call InitializeDC(kr, me, mh)

        call InitializeDephasing(kr, me, mh)
        
        if(Recomb) call InitializeEmission(kr, Ee, Eh, abs(dcv), epsr, gam_eh, ehint)
            
        ! Determine the beginning and ending points of the quantum
        ! wire in the field array y-space. The Quantum wire begins
        ! at point Nr1 and ends at point Nr2, such that L = rr(Nr2)-rr(Nr1).
        Nr1 = locator(rr-r0, r(1))
        Nr2 = locator(rr-r0, r(Nr))

        t    = 0d0
        wph  = (gap + hbar*Oph - hbar*wL) / hbar

        chiw = QWChi1(lam, dkr, Ee+gap, Eh, area, gam_eh, dcv) * ehint**2
  

     
        print*, "Quantum Wire Linear Chi = ", chiw





!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
allocate(game(Nk),gamh(Nk))
game = gam_e
gamh = gam_h
 call RecordXqw(kr, kr*0d0, kr*0d0, Ee, Eh, gap, area, game, gamh, dcv,0)
!  call RecordEpsLqw(Qr, kr*0d0, kr*0d0, Ee, Eh, gap, area, gam_eh, dcv,0)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    

        do w=1, Nw
            write(wire,'(I2.2)') w
            open(unit=uw+w  , file='dataQW/info.'//trim(wire)//'.t.dat')
            open(unit=2*uw+w, file='dataQW/EP.'//trim(wire)//'.t.dat')
            open(unit=3*uw+w, file='dataQW/XQ.'//trim(wire)//'.t.dat')
        end do

        call Calchw(hw, PLS, 0.8*gap, 1.1*(gap+Ee(Nk)+Eh(Nk)) )

        nqq   = locate(Qr, 2.35d7)
        nqq10 = locate(Qr, 2.35d8)

        if(ReadDC) then
            open(unit=666,file="DC.txt")
            read(666,*) Edc
            close(666)
        end if

!    call GetEpsrLEpsrT(1.65d8, abs(dcv), 1417d0, 182d0, me, mh, gap, kr)

    else
    endif


open(unit=923,file="dataQW/Wire/info/ETHz.t.dat")

    end subroutine


    function CalcXqw(iq, w, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv) result(Xqw)
        integer     :: iq
        real(dp)    :: w, kr(:)
        real(dp)    :: fe(:),fh(:)
        real(dp)    :: Ee(:),Eh(:)
        real(dp)    :: gap, area, game(:), gamh(:)
        complex(dp) :: dcv, Xqw
        real(dp)    :: Ev(Nk), Ec(Nk), fv(Nk), fc(Nk), hge(Nk), hgh(Nk)
        real(dp)    :: x, N, dkr
        integer     :: kmin, kmax, ik, k


        dkr = kr(2) - kr(1)

!k=1
!hge(k) = max(1d-4*e0,hbar*game(k))

        forall(k=1:Nk) hge(k) = max(1d-4*e0, hbar*game(k))
        forall(k=1:Nk) hgh(k) = max(1d-4*e0, hbar*gamh(k))

        Ec = gap + Ee
        Ev = - Eh
        fc = fe
        fv = 1d0 - fh

        N  = (2 * dkr / twopi / area)
        x  = N * dcv**2 / eps0 !/ hbar

        Xqw = 0d0

        kmin = max(1-iq,1 )
        kmax = min(Nk-iq,Nk)
        !! FOR THE SAKE OF SANITY LATER,
        !! NOTE THAT THE ABOVE CODE FOR
        !! kmin AND kmax DOES THE FOLLOWING:
        !if(iq>=0) then
        !    kmin=1
        !    kmax=Nk-iq
        !else 
        !    kmin=1-iq
        !    kmax=Nk
        !endif

        do ik=kmin, kmax
            Xqw = Xqw + x * ( fc(ik) - fv(ik+iq) ) &
                          / (Ev(ik+iq) - Ec(ik) - hbar * w -  ii*(hgh(ik+iq) + hge(ik)) )
        end do

        do ik=kmin, kmax
            Xqw = Xqw + x * ( fv(ik) - fc(ik+iq) ) &
                          / (Ec(ik+iq) - Ev(ik) - hbar * w -  ii*(hge(ik+iq) + hgh(ik)))
        end do

    end function


    subroutine RecordEpsLqw(Qr, fe, fh, Ee, Eh, gap, area, gamE, gamH, dcv,ind)
        real(dp)    :: Qr(:),fe(:),fh(:),Ee(:),Eh(:)
        real(dp)    :: gap, area, gamE(:), gamH(:)
        complex(dp) :: dcv
        integer     :: ind
        integer                  :: iq, iw, nwmax, u
        real(dp)                 :: dw, wmax, w, epr, epi, q
        character(len=50)        :: filename, filename2, fmt, file
        real(dp)    :: n1D, maxR, minR, maxI, minI

        wmax = gap / hbar * 2
        dw   = wmax / 2000d0
        nwmax= wmax / dw


        n1D = sum(fe+fh) / 2d0 / L
        n1D = 1.5d8!2.908d8

        u = 911
        fmt = '(I6.6)'
        write(filename ,fmt) ind
        write(filename2,fmt) ind
        filename = 'dataQW/Wire/Xqw/EpsL.'//trim(filename)//'.dat'
        filename2= 'dataQW/Wire/Xqw/ChiL.'//trim(filename2)//'.dat'

        open(file=filename ,unit=u)
        open(file=filename2,unit=u+1)

        do iw = 0, nwmax
            w = iw*dw
            do iq = 0, size(kr)
                q = iq * (kr(2)-kr(1))
                call GetEps1Dqw(alphae, alphah, Delta0, L, epsr, me, mh, n1D, q, w, epr, epi)
                write(u,'(2E12.3)') epr-1d0, epi

                call GetChi1Dqw(alphae, alphah, Delta0, L, epsr, gamE, gamH, kr, Ee, Eh, fe, fh, q, w, epr, epi)
                write(u+1,'(2E12.3)') epr, epi
            end do
        end do        

        close(u)

        if(Xqwparams) then
            u = 912
            open(file='dataQW/Wire/Xqw/EpsL.params',unit=u)
            write(u,*) "Nq =", size(Qr)
            write(u,*) "Nw =", 2000
            write(u,*) " "
            write(u,*) "hbar dw (eV) =", dw*hbar/e0
            write(u,*) "dq (rad/m) =", dkr
            write(u,*) " "
            write(u,*) "wmin =,", -wmax*hbar/e0
            write(u,*) "wmax =,", wmax*hbar/e0
            write(u,*) "qmin =,", qr(1)
            write(u,*) "qmax =,", qr(size(Qr))
            close(u)
            Xqwparams = .false.
        endif
    end subroutine


   subroutine RecordXqw(kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv,ind)
        real(dp)    :: kr(:),fe(:),fh(:),Ee(:),Eh(:)
        real(dp)    :: gap, area, game(:), gamh(:)
        complex(dp) :: dcv
        integer     :: ind

        complex(dp), allocatable :: Xqw(:,:)
        integer                  :: iq, iw, nwmax, u
        real(dp)                 :: dw, wmax
        character(len=50)        :: filename, fmt, file

        wmax = gap / hbar * 2
        dw   = wmax / 2000d0
        nwmax= wmax / dw

        allocate(Xqw(0:Nk, 0:nwmax))

        do iw = 0, nwmax
            do iq = 0, Nk
                Xqw(iq,iw) = CalcXqw(iq, iw*dw, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv)
            end do
        end do

        u = 911
        fmt = '(I6.6)'
        write(filename,fmt) ind
        filename = 'dataQW/Wire/Xqw/Xqw.'//trim(filename)//'.dat'

        open(file=filename,unit=u)

        do iw = 0, nwmax
            do iq = 0, Nk
                !write(u,'(2E12.3)') Real(Xqw(iq,iw)), Aimag(Xqw(iq,iw))
                write(u,'(3E16.6)') iw*dw, Real(Xqw(iq,iw)), Aimag(Xqw(iq,iw))
            end do
        end do        

        close(u)

        if(Xqwparams) then
            u = 912
            open(file='dataQW/Wire/Xqw/Xqw.params',unit=u)
            write(u,*) "Nq =", Nk+1
            write(u,*) "Nw =", nwmax+1
            write(u,*) " "
            write(u,*) "hbar dw (eV) =", dw*hbar/e0
            write(u,*) "dq (rad/m) =", dkr
            write(u,*) " "
            write(u,*) "wmin =,", 0d0 !-wmax*hbar/e0
            write(u,*) "wmax =,", wmax*hbar/e0
            write(u,*) "qmin =,", 0d0 !-Nk*dkr
            write(u,*) "qmax =,",  Nk*dkr
            close(u)
            Xqwparams = .false.
        endif
    end subroutine



    subroutine GetArrays(x, qx, kx)
        real(dp), intent(inout) :: x(:), qx(:), kx(:)
        integer                 :: dnk, k

        dnk  = (Nk-1)/2
        NK0  = dnk + 1

        !forall(k=1:Nk) kx(k) = dkr * (-dnk+k-1)
        !forall(k=1:Nk) kx(k) = dkr * (-dnk+k-1.5d0)

        !if(Nf==1) then
            forall(k=1:Nk) kx(k) = dkr * (-dnk+k-1.5d0)
        !else
        !    forall(k=1:Nk) kx(k) = dkr * (-dnk+k-1)
        !end if

        x     = GetSpaceArray(Nr, 2*L)
        qx    = GetKArray(Nr, 2*L)
        qx    = cshift(qx, Nr/2)
        qx(1) = - qx(1)

        NQ0 =  GetArray0Index(qx)
    end subroutine GetArrays



    
    ! The kkp() arrays gives the index for the Qr field
    ! array for the difference of kr(k) - kr(kp)
    subroutine MakeKKP()
        integer  :: k, kp
        real(dp) :: q

        allocate(kkp(Nk,Nk))

        kkp = 0d0

        do k=1, Nk

            do kp=1, Nk

                q = kr(k) - kr(kp)

               !if(kr(1) <= q .and. q <= kr(Nr)) then
               !     kkp(k,kp)  = nint(q/dkr) + NK0                                        
               ! end if
                
                kkp(k,kp)  = nint(q/dkr) + NQ0

               !if(kkp(k,kp) < 2 .or. kkp(k,kp) > Nr) then
               !    kkp(k,kp) = 0                                       
               !end if                
            end do
        end do	
    end subroutine



    function kindex(k)
        real(dp)  :: k
        integer   :: kindex
        kindex = nint(k/dkr) + NK0 
    end function


    subroutine RelaxationE(ne, nh, VC, E1D, Win, Wout)
        complex(dp), intent(in   ) :: ne(:), nh(:)    ! Carrier populations
        real(dp),    intent(in   ) :: VC(:,:,:)       ! Screened Coulomb collision arrays
        real(dp),    intent(in   ) :: E1D(:,:)        ! Screening array for phonons
        real(dp),    intent(inout) :: Win(:), Wout(:) ! Many-body In/Out rates

        Win  = 0d0
        Wout = 0d0

        if(EHs)     call MBCE(real(ne), real(nh), kr, Ee, Eh, VC, gam_eh, gam_e, Win, Wout)
        
        if(phonon)  call MBPE(real(ne), VC, E1D, Win, Wout)

    end subroutine RelaxationE


    
    subroutine RelaxationH(ne, nh, VC, E1D, Win, Wout)
        complex(dp), intent(in   ) :: ne(:), nh(:)    ! Carrier populations
        real(dp),    intent(in   ) :: VC(:,:,:)       ! Screened Coulomb collision arrays
        real(dp),    intent(in   ) :: E1D(:,:)        ! Screening array for phonons
        real(dp),    intent(inout) :: Win(:), Wout(:) ! Many-body In/Out rates

        Win  = 0d0
        Wout = 0d0

        if(EHs)     call MBCH(real(ne), real(nh), kr, Ee, Eh, VC, gam_eh, gam_h, Win, Wout)
        
        if(phonon)  call MBPH(real(nh), VC, E1D, Win, Wout)

    end subroutine RelaxationH

    
    subroutine Preparation(P, C, D, Ex, Ey, Ez, Vr, Heh, Hee, Hhh, VC, E1D, GamE, GamH, OffG, Rsp)
        complex(dp), intent(in)    :: P(:,:),C(:,:),D(:,:)    ! Electron-hole coherence
        complex(dp), intent(in)    :: Ex(:), Ey(:), Ez(:)     ! Electric field components
        complex(dp), intent(in)    :: Vr(:)                   ! Electric free-charge potential
        complex(dp), intent(inout) :: Heh(:,:)                ! Hamiltonian e-e matrix elements
        complex(dp), intent(inout) :: Hee(:,:)                ! Hamiltonian h-h matrix elements
        complex(dp), intent(inout) :: Hhh(:,:)                ! Hamiltonian e-h matrix elements
        real(dp),    intent(inout) :: VC(:,:,:), E1D(:,:)     ! Screened Coulomb Arrays
        real(dp),    intent(inout) :: GamE(:), GamH(:)        ! Diagonal Dephasing Rates
        complex(dp), intent(inout) :: OffG(:,:,:)             ! Off-Diagonal Dephasing Rates
        real(dp),    intent(inout) :: Rsp(:)                  ! Spontaneous Emission rate
        real(dp)                   :: g(3)
        complex(dp)                :: Meh(Nk,Nk)              ! EH dipole matrix elements
        complex(dp)                :: Wee(Nk,Nk),Whh(Nk,Nk)   ! EE & HH monopole matrix elements
        complex(dp)                :: ne(Nk), nh(Nk)  	      ! Carrier populations
        integer :: f, k


        ! Initialize Dipole-Exciton Coupling and Screened Coulomb arrays
        Meh  = 0d0
        Wee  = 0d0
        Whh  = 0d0
        ne   = 0d0
        nh   = 0d0
        VC   = 0d0
        GamE = gam_e
        GamH = gam_h
        OffG = 0d0
        Rsp  = 0d0
        g(2) = gam_e
        g(3) = gam_h
        g(1) = gam_eh
        
        ! Get ne and nh
        forall(k=1:Nk) ne(k) = C(k,k)
        forall(k=1:Nk) nh(k) = D(k,k)

        ! Calculate the dipole coupling matrix shared by all three SBEs
        if(Optics) call CalcMeh(Ex, Ey, Ez, Meh)

        ! Calculate the monopole matrix elements if .photonics. is on
!        if(Optics .and. LF) call CalcWnn(-e0, Vr, Wee) 
!        if(Optics .and. LF) call CalcWnn(+e0, conjg(Vr), Whh)


        ! Screen the Coulomb collision arrays
        call CalcScreenedArrays(screened, L, ne, nh, VC, E1D)

        ! Calc the Hamiltonian matrix elements
        call CalcH(Meh, Wee, Whh, C, D, p, VC, Heh, Hee, Hhh)
            
        ! Calculate the Exciton correction array for SBEs, if needed
        !if(Excitons .and. optics) call CalcMVeh(p, VC, MVeh)

        ! Calculate the diagonal electron dephasing rate
        if(DiagDph) call CalcGammaE(kr, ne, nh, VC, GamE)

        ! Calculate the diagonal hole dephasing rate
        if(DiagDph) call CalcGammaH(kr, ne, nh, VC, GamH)
        
        ! Calculate the diagonal hole dephasing rate
        if(OffDiagDph) then
            call OffDiagDephasing2(ne, nh, p(:,:), kr, Ee, Eh, g, VC, t, OffG(:,:,1))
        endif
        
        !Calculate the Spontaneous emission rate, if needed
        if(Recomb) call SpontEmission(ne, nh, Ee, Eh, gap, gam_eh, VC, Rsp)      

    end subroutine Preparation



    subroutine CalcH(Meh, Wee, Whh, C, D, p, VC, Heh, Hee, Hhh)
        complex(dp), intent(in   ) :: Meh(:,:)
        complex(dp), intent(in   ) :: Wee(:,:)
        complex(dp), intent(in   ) :: Whh(:,:)
        complex(dp), intent(in   ) :: C(:,:)
        complex(dp), intent(in   ) :: D(:,:)
        complex(dp), intent(in   ) :: p(:,:)
        real(dp),    intent(in   ) :: VC(:,:,:)
        complex(dp), intent(inout) :: Heh(:,:), Hee(:,:), Hhh(:,:)
        integer                    :: k1, k2, n, q, k, ke, kh
        real(dp)                   :: V(-Nk:Nk,3)
        complex(dp)                :: Ct(size(C,1),size(C,2))
        complex(dp)                :: Dt(size(D,1),size(D,2))
        complex(dp)                :: pt(size(p,1),size(p,2))
        integer                    :: noq0(-2*Nk:2*Nk)
        noq0(-2*Nk:2*Nk) = 1        
        noq0(0) = 0

        V = 0d0
        Ct = transpose(C)
        Dt = transpose(D)
        pt = transpose(p)                

        ! Set up 1D Vq calculation.
        ! Note that Vq = 0 for q = 0
        forall(q=1:Nk-1) V(+q,:) = VC(1+q,1,:)
        forall(q=1:Nk-1) V(-q,:) = VC(1+q,1,:)

        ! Initialize Hamiltonian
        Heh = 0d0
        Hee = 0d0
        Hhh = 0d0

        ! Set up single particle energies
        forall(k=1:Nk) Hee(k,k) = Ee(k) + Gap
        forall(k=1:Nk) Hhh(k,k) = Eh(k)


        ! Set up potential matrix elements under dipole approximation
        Heh(:,:) = Meh(:,:)   
        if (FreePot) then     
            Hee(:,:) = Hee(:,:) + Wee(:,:)
            Hhh(:,:) = Hhh(:,:) + Whh(:,:)
        endif


        if(excitons .and. LF)then
            ! Calculate H^{e,h}_{k_1,k_2}
            !$omp parallel do private(k2, k1, q)
            do k2=1, Nk
                do k1=1, Nk
		            do q=max(1-k1,1-k2), min(Nk-k1,NK-k2)
                        Heh(k1,k2) = Heh(k1,k2) + V(q,1) * pt(k1+q,k2+q) * noq0(q)
                    end do
                end do
            end do
            !$omp end parallel do

            !$omp parallel do private(k2, k1, q, k)
            do k2=1, Nk
                do k1=1, Nk
                    do q=max(1-k1,1-k2), min(Nk-k1,NK-k2)
                        Hee(k1,k2) = Hee(k1,k2) - V(q,2) * (Ct(k1+q,k2+q)) * noq0(q)
                    end do
                                        
                    q = k1-k2
                    do k = max(1,1-q), min(Nk, Nk-q) 
                    	Hee(k1,k2) = Hee(k1,k2) + (V(q,2) * C(k,k+q) - V(q,3) * D(k+q,k)) * noq0(q) 
                    end do
                end do
            end do
            !$omp end parallel do


            !$omp parallel do private(k2, k1, q, k)
            do k2=1, Nk
                do k1=1, Nk
		            do q=max(1-k1,1-k2), min(Nk-k1,NK-k2)
                        Hhh(k1,k2) = Hhh(k1,k2) - V(q,3) * (Dt(k1+q,k2+q)) * noq0(q)
                    end do
                    
                    q = k1-k2
                    do k = max(1,1-q), min(Nk, Nk-q) 
                    	Hhh(k1,k2) = Hhh(k1,k2) + (V(q,3) * D(k,k+q) - V(q,3) * C(k+q,k)) * noq0(q)
                    end do
                end do
            end do
            !$omp end parallel do

        end if
       
        
        if(excitons .and. .not.LF)then
            ! Calculate H^{e,h}_{k_1,k_2}
            !$omp parallel do private(k2, k1, q)
            do k2=1, Nk
                do k1=1, Nk
		            do q=max(1-k1,1-k2), min(Nk-k1,NK-k2)
                        Heh(k1,k2) = Heh(k1,k2) + V(q,1) * pt(k1+q,k2+q) * noq0(q)
                    end do
                end do
            end do
            !$omp end parallel do


            !$omp parallel do private(k2, k1, q, k)
            do k2=1, Nk
                k1=k2
                do q=max(1-k1,1-k2), min(Nk-k1,NK-k2)
                    Hee(k1,k2) = Hee(k1,k2) - V(q,2) * Ct(k1+q,k2+q) * noq0(q)
                end do
            end do
            !$omp end parallel do


            !$omp parallel do private(k2, k1, q, k)
            do k2=1, Nk
                k1=k2
		        do q=max(1-k1,1-k2), min(Nk-k1,NK-k2)
                    Hhh(k1,k2) = Hhh(k1,k2) - V(q,3) * Dt(k1+q,k2+q) * noq0(q)
                end do
            end do
            !$omp end parallel do
        end if
    end subroutine


    
    function chiqw()
        complex :: chiqw
        chiqw = chiw
    end function


    
    real function getqc()
        getqc = qc
    end function
    
    
    
    subroutine Checkout(P1, P2, C1, C2, D1, D2, w)
        complex(dp), intent(inout) :: P1(:,:), P2(:,:)
        complex(dp), intent(inout) :: C1(:,:), C2(:,:)
        complex(dp), intent(inout) :: D1(:,:), D2(:,:)
        integer,     intent(in   ) :: w
   
        P1(:,:) = YY2(:,:,w)
        P2(:,:) = YY3(:,:,w)

        C1(:,:) = CC2(:,:,w)
        C2(:,:) = CC3(:,:,w)

        D1(:,:) = DD2(:,:,w)
        D2(:,:) = DD3(:,:,w)
    end subroutine
    
    
    subroutine Checkin(P1, P2, P3, C1, C2, C3, D1, D2, D3, w)
        complex(dp), intent(inout) :: P1(:,:), P2(:,:), P3(:,:)
        complex(dp), intent(inout) :: C1(:,:), C2(:,:), C3(:,:)
        complex(dp), intent(inout) :: D1(:,:), D2(:,:), D3(:,:)
        integer,     intent(in   ) :: w
   
        YY1(:,:,w) = P1(:,:)
        YY2(:,:,w) = P2(:,:)
        YY3(:,:,w) = P3(:,:)

        CC1(:,:,w) = C1(:,:)
        CC2(:,:,w) = C2(:,:)
        CC3(:,:,w) = C3(:,:)

        DD1(:,:,w) = D1(:,:)
        DD2(:,:,w) = D2(:,:)
        DD3(:,:,w) = D3(:,:)
    end subroutine


    function QWArea() 
        real(dp) :: QWArea
        QWArea = area !/ ehint
    end function


    subroutine ShutOffOptics()
        Optics = .false.
    end subroutine

    subroutine ReadQWParams()
        open(unit=495,file='params/qw.params')
            ! Read in QW Parameters
            read(495,*) L      ! Length of quantum wire (m)
            read(495,*) Delta0 !z-thickness of quantum wire (m)
            read(495,*) gap    ! Band gap (J, eV=1.6d-19 J)  1.53 eV
            read(495,*) me     ! Electron effective mass (kg, me0=9.11e-31 kg)
            read(495,*) mh     ! Electron effective mass (kg, me0=9.11e-31 kg)
            read(495,*) HO     ! Energy level separation (J, default 100 meV)
            read(495,*) gam_e  ! Electron lifetime frequency(Hz)
            read(495,*) gam_h  ! Hole lifetime frequency (Hz)
            read(495,*) gam_eh ! Energy level broading rate (Hz), gam_eh = (gam_e + gam_h)/2
            read(495,*) epsr   ! Background dielectric constant
            read(495,*) Oph    ! Phonon frequency (Hz)
            read(495,*) Gph    ! Inverse phonon lifetime (Hz)
            read(495,*) Edc    ! Background DC field in +y-direction (V/m)
            read(495,*) jmax   ! Print data files every jmax t-steps
            read(495,*) ntmax  ! 
        close(495)

        gap = gap * eV
        me  = me  * me0
        mh  = mh  * me0
        HO  = HO  * eV
        Oph = Oph * eV/hbar
        Gph = Gph * eV/hbar
    end subroutine

        
    subroutine ReadMBParams()
        logical :: LorentzDelta
        open(unit=495,file='params/mb.params')
            ! Read in QW Parameters
            read(495,*) Optics
            read(495,*) Excitons
            read(495,*) EHs
            read(495,*) Screened
            read(495,*) Phonon
            read(495,*) DCTrans
            read(495,*) LF
            read(495,*) FreePot
            read(495,*) DiagDph
            read(495,*) OffDiagDph
            read(495,*) Recomb
            read(495,*) PLSpec
            read(495,*) ignorewire
            read(495,*) Xqwparams
            read(495,*) LorentzDelta
        close(495)
        call SetLorentzDelta(LorentzDelta)   
    end subroutine 

  
    subroutine WriteSBEsData(n)
        integer, intent(in) :: n
        integer             :: k1, k2, w
        character(len=150)  :: C1,C2,C3,D1,D2,D3,Y1,Y2,Y3,backup
        
        backup="dataQW/backup/"
        C1 = trim(backup) // "CC1." // int2str(n) // ".dat"
        C2 = trim(backup) // "CC2." // int2str(n) // ".dat"
        C3 = trim(backup) // "CC3." // int2str(n) // ".dat"
        D1 = trim(backup) // "DD1." // int2str(n) // ".dat"
        D2 = trim(backup) // "DD2." // int2str(n) // ".dat"
        D3 = trim(backup) // "DD3." // int2str(n) // ".dat"
        Y1 = trim(backup) // "YY1." // int2str(n) // ".dat"
        Y2 = trim(backup) // "YY2." // int2str(n) // ".dat"
        Y3 = trim(backup) // "YY3." // int2str(n) // ".dat"
        
        
        open(file=trim(C1),unit=701)
        open(file=trim(C2),unit=702)
        open(file=trim(C3),unit=703)
        open(file=trim(D1),unit=704)
        open(file=trim(D2),unit=705)
        open(file=trim(D3),unit=706)
        open(file=trim(Y1),unit=707)
        open(file=trim(Y2),unit=708)
        open(file=trim(Y3),unit=709)

        do w=1, size(CC1,3)
            do k2=1, Nk
                do k1=1, Nk
                    write(701,*) CC1(k1,k2,w)
                    write(702,*) CC2(k1,k2,w)
                    write(703,*) CC3(k1,k2,w)
                    write(704,*) DD1(k1,k2,w)
                    write(705,*) DD2(k1,k2,w)
                    write(706,*) DD3(k1,k2,w)
                    write(707,*) YY1(k1,k2,w)
                    write(708,*) YY2(k1,k2,w)
                    write(709,*) YY3(k1,k2,w)
                end do
            end do
        end do

        close(701)
        close(702)
        close(703)
        close(704)
        close(705)
        close(706)
        close(707)
        close(708)
        close(709)  
    end subroutine


    subroutine ReadSBEsData(Nt)
        integer, intent(in) :: Nt
        integer             :: k1, k2, w
        character(len=150)  :: C1,C2,C3,D1,D2,D3,Y1,Y2,Y3,backup
        
        backup="dataQW/backup/"
        C1 = trim(backup) // "CC1." // int2str(Nt) // ".dat"
        C2 = trim(backup) // "CC2." // int2str(Nt) // ".dat"
        C3 = trim(backup) // "CC3." // int2str(Nt) // ".dat"
        D1 = trim(backup) // "DD1." // int2str(Nt) // ".dat"
        D2 = trim(backup) // "DD2." // int2str(Nt) // ".dat"
        D3 = trim(backup) // "DD3." // int2str(Nt) // ".dat"
        Y1 = trim(backup) // "YY1." // int2str(Nt) // ".dat"
        Y2 = trim(backup) // "YY2." // int2str(Nt) // ".dat"
        Y3 = trim(backup) // "YY3." // int2str(Nt) // ".dat"
        
        
        open(file=trim(C1),unit=701)
        open(file=trim(C2),unit=702)
        open(file=trim(C3),unit=703)
        open(file=trim(D1),unit=704)
        open(file=trim(D2),unit=705)
        open(file=trim(D3),unit=706)
        open(file=trim(Y1),unit=707)
        open(file=trim(Y2),unit=708)
        open(file=trim(Y3),unit=709)

        do w=1, size(CC1,3)
            do k2=1, Nk
                do k1=1, Nk
                    read(701,*) CC1(k1,k2,w)
                    read(702,*) CC2(k1,k2,w)
                    read(703,*) CC3(k1,k2,w)
                    read(704,*) DD1(k1,k2,w)
                    read(705,*) DD2(k1,k2,w)
                    read(706,*) DD3(k1,k2,w)
                    read(707,*) YY1(k1,k2,w)
                    read(708,*) YY2(k1,k2,w)
                    read(709,*) YY3(k1,k2,w)
                end do
            end do
        end do

        close(701)
        close(702)
        close(703)
        close(704)
        close(705)
        close(706)
        close(707)
        close(708)
        close(709)  
    end subroutine

        
end module
